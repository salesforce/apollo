/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
package com.salesforce.apollo.ethereal;

import java.math.BigInteger;
import java.security.PublicKey;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.stream.IntStream;

import javax.crypto.SecretKey;

import com.salesfoce.apollo.ethereal.proto.Proof;
import com.salesforce.apollo.crypto.JohnHancock;
import com.salesforce.apollo.ethereal.WeakThresholdKey.ThresholdKey;
import com.salesforce.apollo.ethereal.creator.EpochProofBuilder.DecodedShare;
import com.salesforce.apollo.ethereal.creator.EpochProofBuilder.Share;

/**
 * @author hal.hildebrand
 *
 */
@SuppressWarnings("unused")
public record WeakThresholdKey(ThresholdKey tk, Map<Short, Boolean> shareProviders) {

    static BigInteger poly(List<BigInteger> coeffs, BigInteger x) {
        var ans = BigInteger.valueOf(0);
        for (var c : coeffs) {
            ans = ans.multiply(x);
            ans = ans.add(c);
            ans = ans.mod(Order);
        }
        return ans;
    }

    /**
     * Returns a Threshold Signature Scheme based on given slice of coefficients.
     **/
    private static TSS newTss(short nProc, List<BigInteger> coeffs) {
        short threshold = (short) coeffs.size();
        var secret = coeffs.get(threshold - 1);

        VerificationKey globalVK = null; // bn256.NewVerificationKey(secret);

        var sks = new ArrayList<SecretKey>();
        var vks = new ArrayList<SymetricKey>();

        IntStream.range(0, nProc).parallel().forEach(p -> {
            short i = 0;
            var s = poly(coeffs, BigInteger.valueOf(i));
//            sks.put(i, bn256.NewSecretKey(s));
//            vks.put(i, bn256.NewVerificationKey(s));
        });

        return new TSS(threshold, globalVK, vks, sks);
    }

    // Order is the number of elements in both G₁ and G₂: 36u⁴+36u³+18u²+6u+1.
    // order-1 = (2**5) * 3 * 5743 * 280941149 * 130979359433191 *
    // 491513138693455212421542731357 * 6518589491078791937
    static BigInteger Order = new BigInteger("65000549695646603732796438742359905742570406053903786389881062969044166799969");

    interface CipherText {

    }

    interface SymetricKey {

    }

    interface VerificationKey {

    }

    public static BigInteger betweenOand(Random entropy, BigInteger upperLimit) {
        BigInteger randomNumber;
        do {
            randomNumber = new BigInteger(upperLimit.bitLength(), entropy);
        } while (randomNumber.compareTo(upperLimit) >= 0);
        return randomNumber;
    }

    /**
     * TSS is a set of all raw threshold keys generated by a dealer for all parties.
     */
    record TSS(short threshold, VerificationKey globalVK, // *bn256.VerificationKey
               List<SymetricKey> vks, // []*bn256.SymetricKey
               List<SecretKey> sks) {

        // Encrypt encrypts secretKeys of the given TSS
        // using given a set of encryptionKeys and returns an (unowned)ThresholdKey.
        public ThresholdKey encrypt(List<SymetricKey> encryptionKeys) {
            short nProc = (short) encryptionKeys.size();
            List<CipherText> encSKs = new ArrayList<CipherText>();

            for (short i = 0; i < nProc; i++) {
//                CipherText encSK = encryptionKeys.get(i).encrypt(sks.get(i).marshal());
//                if (encSK == null) {
//                    return null;
//                }
//                encSKs.add(encSK);
            }

            return new ThresholdKey((short) 0, (short) 0, threshold, globalVK, vks, encSKs, (SecretKey) null);
        }
    }

    public record ThresholdKey(short owner, short dealer, short threshold, VerificationKey globalVK,
                               List<SymetricKey> vks, List<CipherText> encSKs, SecretKey sk) {
        // Encode returns a byte representation of the given (unowned) ThresholdKey in
        // the following form
        // (1) threshold, 2 bytes as uint16
        // (2) length of marshalled globalVK, 4 bytes as uint32
        // (3) marshalled globalVK
        // (4) len(vks), 4 bytes as uint32
        // (5) Marshalled vks in the form
        // a) length of marshalled vk
        // b) marshalled vk
        // (6) Encrypted sks in the form
        // a) length of the cipher text
        // b) cipher text of the key
        byte[] encode() {

            var data = new byte[2 + 4];
//            binary.LittleEndian.PutUint16(data[:2], tk.threshold);

//            var globalVKMarshalled = globalVK.marshal();
//            binary.LittleEndian.PutUint32(data[2:6], uint32(len(globalVKMarshalled)));
//            data = append(data, globalVKMarshalled...);

            var dataLen = new byte[4];
//            binary.LittleEndian.PutUint32(dataLen[:], uint32(len(tk.vks)));
//            data = append(data, dataLen...);

//            for (var vk :  tk.vks()) {
//                var vkMarshalled = vk.marshal();
//                binary.LittleEndian.PutUint32(dataLen, vkMarshalled.size()));
//                data = append(data, dataLen...);
//                data = append(data, vkMarshalled...);
//            }
//
//            for (var encSK:   tk.encSKs()) {
//                binary.LittleEndian.PutUint32(dataLen, uint32(len(encSK)));
//                data = append(data, dataLen...);
//                data = append(data, encSK...);
//            }
            return data;
        }
    }

    // SeededWTK returns a WeakThresholdKey generated by the provided seed.
    // NOTE! This function is not safe, should be used for testing purposes only!
    public static WeakThresholdKey seededWTK(short nProc, short pid, long seed, Map<Short, Boolean> shareProviders) {
        var rnd = new Random(seed);
        var threshold = Dag.minimalTrusted(nProc);

        var coeffs = new ArrayList<BigInteger>();
        for (short i = 0; i < threshold; i++) {
            coeffs.add(betweenOand(rnd, Order));
        }

        var sKeys = new ArrayList<SecretKey>();
        var pKeys = new ArrayList<PublicKey>();
        for (short i = 0; i < nProc; i++) {
//            KeyPair keyPair = p2p.GenerateKeys();
        }
        short dealer = 0;

//        List<SymetricKey> p2pKeys = p2p.Keys(sKeys.get(dealer), pKeys, dealer);

        TSS gtk = newTss(nProc, coeffs);
//        var tkEncrypted = gtk.encrypt(p2pKeys);
//        var tk = decode(tkEncrypted.encode(), dealer, pid, p2pKeys.get(pid));

        if (shareProviders == null) {
            shareProviders = new HashMap<>();
            for (short i = 0; i < nProc; i++) {
                shareProviders.put(i, true);
            }
        }
        return null;
//        return new WeakThresholdKey(new ThresholdKey(pid, dealer, threshold, null, p2pKeys, null, null),
//                                    shareProviders);
    }

    // CreateWTK generates a weak threshold key for the given ThresholdKeys
    // i.e. a ThresholdKey which corresponds to the sum of polynomials
    // which are defining the given ThresholdKeys. Shares may be produced only by
    // shareProviders.
    // We assume that:
    //
    // (0) tks is a non-empty slice
    // (1) the threshold is the same for all given thresholdKeys
    // (2) the thresholdKeys were created by different processes
    // (3) the thresholdKeys have the same owner
    //
    // The resulting WeakThresholdKey has undefined dealer and encSKs.
//    static WeakThresholdKey createWTK(List<ThresholdKey> tks, Map<Short, Boolean> shareProviders) {
//        var n = tks.get(0).vks().size();
//
//        SecretKey sk;
//        VerificationKey globalVK;
//        List<VerificationKey> vks = new ArrayList<>();
//        for (var tk : tks) {
////            sk = bn256.AddSecretKeys(sk, tk.sk);
////            globalVK = bn256.AddVerificationKeys(globalVK, tk.globalVK);
//
//            for (int i = 0; i < tk.vks().size(); i++) {
////                vks.add(bn256.AddVerificationKeys(vks.get(i), tk.vks().get(i)));
//            }
//        }
//
////        ThresholdKey tk = new ThresholdKey(tks.get(0).owner(), (short) 0, tks.get(0).threshold(), globalVK,
////                                           new ArrayList<>(), new ArrayList<>(), sk);
//        return new WeakThresholdKey(tk, shareProviders);
//    }

    public boolean verifySignature(JohnHancock sig, Proof msg) {
        return false;
    }

    public Share createShare(Proof proof) {
        // TODO Auto-generated method stub
        return null;
    }

    public int threshold() {
        // TODO Auto-generated method stub
        return 0;
    }

    public JohnHancock combineShares(Collection<Share> shareSlice) {
        return null;
    }

    public boolean verifyShare(DecodedShare share) {
        // TODO Auto-generated method stub
        return false;
    }

}
